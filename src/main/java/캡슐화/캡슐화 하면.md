## 2. 캡슐화를 하면!

### 캡슐화란 ?
1. 데이터 + 관련 기능을 하나로 묶고, 구현 상세를 감추는 것(은닉의 의미).
2. 예전에는 은닉과 캡슐화를 구분하여 표현하였지만 , 지금은 캡슐화안에 의미가 내포되어있다.

### 캡슐화를 하는 이유 
1. 외부에 영향없이 객체 내부 구현 변경이 가능하다

2. 1번, 어떻게 가능할까?
    1. 요구사항이 바뀜
    2. 데이터 구조 / 사용에 변화를 발생시킴
    3. 데이터를 사용하는 코드 수정 발생
    4. 캡슐화가 되어 있다면? : 
       그 과정에서 캡슐화가 되어있다면 그 요구조건을 실행하는 메서드의 내용만 바뀔 뿐
       메서드를 사용한 코드는 바뀌지 않는다.
       
       
요구사항 변경 전
```java
if(acc.hasRegularPermission()) {
   ...정회원 기능    
}
```
```java
public class Account {
    private Membership membership;
    private Date expDate;
    
    public boolean hasRegularPermission() {
        return membership == REGULAR && 
                expDate.isAfter(now())
    }
}
```

요구사항 변경 후 (내부 구현만 변경)
```java
if(acc.hasRegularPermission()) {
   ...정회원 기능    
}
```
```java
public class Account {
  
    public boolean hasRegularPermission() {
        return membership == REGULAR && 
            (expDate.isAfter(now()) ||
              (
               serviceDate.isBefore(fiveYearAgo()) &&
               addMonth(expDate).isAfter(now())        
              )
            );
    }
}
```

### 캡슐화의 장점
1. 연쇄적인 변경 전파를 최소화 시킨다.
2. 캡슐화 된 기능을 사용하는 코드 영향을 최소화 한다.
3. 캡슐화를 잘하게 되면 (실행하게 되면) 기능에 대한 이해를 높인다.

### 캡슐화의 규칙
- tell, Don't Ask
-> 데이터 달라하지 말고 데이터를 가진 것에게 직접 해달라고 하기
  
- Demeter's Law
-> 메서드 하나를 호출하는 형식으로 바꾸어라 
  1. 메서드에서 생성한 객체의 메서드만 호출
  2. 파라미터로 받은 객체의 메서드만 호출
  3. 필드로 참조하는 객체의 메서드만 호출
    
```java
ex ) 
    acc.getExpDate().isAfter(now) => acc.isExpired()
        
    Date date = acc.getExpDate();
    date.isAfter(now);             => acc.isValid(now)

- 연쇄적인 호출이 아닌 , 하나를 호출하는 형식으로 바꾸는 것.
```
